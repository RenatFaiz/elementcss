// _css.scss description

// clearfix
// is technique of overflow correction
// to block element containing float elements
@mixin clearfix() {
  &::after {
    content: "";
    display: table;
    clear: both;
  }
}
@mixin _clearfix() { // deprecated
  &::before,
  &::after {
     content: " ";
     display: table;
  }
  &::after {
     clear: both;
  }
}


// font-face
// generate bulletproof @font-face rule for your custom fonts.
// there is great tool: fontsquirrel.com/tools/webfont-generator
@mixin font-face($font-family, $font-path, $formats:null, $font-weight:normal, $font-style:normal, $svg-font-name:null, $version:null) {
  $src: ();
  // append query param to font path it's useful if we
  // update the font and want to reset browser cache as well
  $query: if($version,'?v=#{$version}', null);
  $add-query: if($version,'&v=#{$version}', null);
  @font-face {
    font-family: $font-family;
    font-weight: $font-weight;
    font-style: $font-style;

    // aggregate each font format separately
    @if index($formats, eot) {
      $src: append($src,
      unquote("url('#{$font-path}.eot#{$query}'); src: url('#{$font-path}.eot?#iefix#{$add-query}') format('embedded-opentype')"), comma);
    }
    @if index($formats, woff2) {
      $src: append($src, unquote("url('#{$font-path}.woff2') format('woff2')"), comma);
    }
    @if index($formats, woff) {
      $src: append($src, unquote("url('#{$font-path}.woff') format('woff')"), comma);
    }
    @if index($formats, ttf) {
      $src: append($src, unquote("url('#{$font-path}.ttf') format('truetype')"), comma);
    }
    @if index($formats, svg) {
      $svg-font-name: if($svg-font-name, $svg-font-name, $font-family);
      $src: append($src, unquote("url('#{$font-path}.svg#{$query}##{$svg-font-name}') format('svg')"), comma);
    }

    // render
    src: $src;
  }
}


// icon-set
// generate bare minimum of styles to use font icons.
// style rules inspired by FontAwesome and Web Starter Kit
@mixin icon-set($font-family:null, $class-prefix:null, $pseudo-element:before, $content-map:(), $from-title:false) {
  .#{$class-prefix}, .#{$class-prefix}-after::after, .#{$class-prefix}-before::before {
    display: inline-block;
    font-family: $font-family;
    font-style: normal;
    font-variant: normal;
    font-weight: normal;
    font-size: inherit;
    line-height: inherit;
    text-rendering: auto;
    //width: 1em;
    //height: 1em;
    //line-height: 1;
    text-transform: none;
    letter-spacing: normal;
    word-wrap: normal;
    // Support for all WebKit browsers.
    -webkit-font-smoothing: antialiased;
    // Support for Firefox.
    -moz-osx-font-smoothing: grayscale;
    // Support for Safari and Chrome.
    text-rendering: optimizeLegibility;
    // Support for IE.
    font-feature-settings: 'liga';
    @content;
  }

  @if $from-title {
    .#{$class-prefix}-prefix::before {
      content: attr(title);
    }
    .#{$class-prefix}-postfix::after {
      content: attr(title);
    }
  }

  @if length($content-map) > 0 {
    @each $key, $value in $content-map {
      .#{$class-prefix}-#{$key}::#{$pseudo-element} {
        content: '#{$value}';
      }
    }
  }
}


// media
// build ...
// $media-map map - map where key is name of query, value is the query itself. Example:
//    $media-map: (
//       mobile:   media '(screen and (max-width: 740px )',
//       touch:    '.touch',
//       ^name     ^query
//    );
// $media-name string - key of corresponding key-value pair in $media-map. Example: mobile or touch
// $unit unit - convert numbers are presented in query in accordance with $unit
@mixin media($media-name, $media-map:null, $unit:$_media-unit) {
  // if media map is not null
  @if $media-map {
    // get query with the associated name
    $media-query: map-get($media-map, $media-name);
    // if query is presented in the map
    @if $media-query {
      $query-string: ();
      $query-type: null;
      // fetch query string from key's value
      @for $i from 1 through length($media-query) {
        $value: nth($media-query, $i);
        // if first item of query is 'media' keyword the content must be under @media rule
        // else under simple CSS selector, like .myclass {@content;}
        @if $i == 1 {
          $query-type: if($value==media, media, selector);
        }
        // if one of the query item is number - convert it according to $unit unit
        $value: if(type-of($value)==number, round-unit($value, $unit), unquote($value));
        // fetch query string
        $query-string: append($query-string, if($value!=media, $value, null));
      }

      @if $query-type == media {
        @media #{$query-string} { @content; }
      } @else if $query-type == selector{
        #{$query-string} { @content; }
      }

    // render content with no query
    } @else {
      @content;
    }
  } @else {
    @content;
  }
}