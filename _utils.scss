// Clearfix
// --------------------------------------------------
// clearfix - is technique of overflow correction
// to block element containing float elements
@mixin clearfix() {
  &::after {
    content: "";
    display: table;
    clear: both;
  }
}
@mixin _clearfix() {
  &::before,
  &::after {
     content: " ";
     display: table;
  }
  &::after {
     clear: both;
  }
}


// Font-Face
// --------------------------------------------------
// Generate bulletproof @font-face rule for your custom fonts.
// there is great tool: fontsquirrel.com/tools/webfont-generator
@mixin font-face($font-family, $font-path, $formats:null, $font-weight:normal, $font-style:normal, $svg-font-name:null, $version:null) {
  $src: ();
  // append query param to font path it's useful if we
  // update the font and want to reset browser cache as well
  $query: if($version,'?v=#{$version}', null);
  $add-query: if($version,'&v=#{$version}', null);
  @font-face {
    font-family: $font-family;
    font-weight: $font-weight;
    font-style: $font-style;

    // aggregate each font format separately
    @if index($formats, eot) {
      $src: append($src,
      unquote("url('#{$font-path}.eot#{$query}'); src: url('#{$font-path}.eot?#iefix#{$add-query}') format('embedded-opentype')"), comma);
    }
    @if index($formats, woff2) {
      $src: append($src, unquote("url('#{$font-path}.woff2') format('woff2')"), comma);
    }
    @if index($formats, woff) {
      $src: append($src, unquote("url('#{$font-path}.woff') format('woff')"), comma);
    }
    @if index($formats, ttf) {
      $src: append($src, unquote("url('#{$font-path}.ttf') format('truetype')"), comma);
    }
    @if index($formats, svg) {
      $svg-font-name: if($svg-font-name, $svg-font-name, $font-family);
      $src: append($src, unquote("url('#{$font-path}.svg#{$query}##{$svg-font-name}') format('svg')"), comma);
    }

    // render
    src: $src;
  }
}


// Icon-set
// --------------------------------------------------
// Generate bare minimum of styles to use font icons.
// Style rules inspired by FontAwesome and Web Starter Kit
@mixin icon-set($font-family:null, $class-prefix:null, $content-map:(), $pseudo-element:before, $from-title:true) {
  .#{$class-prefix} {
    display: inline-block;
    font-family: $font-family;
    font-style: normal;
    font-variant: normal;
    font-weight: normal;
    font-size: inherit;
    line-height: inherit;
    text-rendering: auto;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  @if $from-title {
    .#{$class-prefix}-prefix::before {
      content: attr(title);
    }
    .#{$class-prefix}-postfix::after {
      content: attr(title);
    }
  }

  @if length($content-map) > 0 {
    @each $key, $value in $content-map {
      .#{$class-prefix}-#{$key}::#{$pseudo-element} {
        content: '#{$value}';
      }
    }
  }
}


// Functions implementing Element's base functionality
// --------------------------------------------------
// Prefixer & Postfixer (with validation)
// -------------------------
// Because of frequent use the functions have very short name.
// _() - prepend prefix for given $value if it isn't equal to $exception
@function _($value, $prefix:'-', $prependOnNull:false, $exception:default, $ifException:null) {
  @return if($value == $exception, $ifException, if($value, #{$prefix}#{$value}, if($prependOnNull, #{$prefix}, null)));
}

// __() - appends postfix for given $value if it isn't equal to $exception
@function __($value, $postfix:'-', $appendOnNull:false, $exception:default, $ifException:null) {
  @return if($value == $exception, $ifException, if($value, #{$value}#{$postfix}, if($appendOnNull, #{$postfix}, null)));
}

// Check if word exists in the string
// -------------------------
// @return null if word doesn't exists else return 1
// or index of char (if length of word == 1)
@function str-exists($string, $word) {
  $word-length: str-length($word);

  @if $word-length <= str-length($string) {
    @if $word-length > 1 {
      $next: 0;
      @for $i from 1 through $word-length {
        $letter: str-slice($word, $i, $i);

        $curr: str-index($string, $letter);
        @if $curr == null {
          @return null;
        }

        @if $i > 1 and $next - $curr != -1 {
          @return null;
        }

        $next: str-index($string, $letter);
        @if $next == null {
          @return null;
        }

      }
      @return true;
    }

    @else if $word-length == 1 {
      @return str-index($string, $word);

    } @else {
      @return null;
    }
  }

  @return null;
}

// Index getter
// -------------------------
// returns list positions of a values in $list-1 that exists in $list-2
@function indexes($list-1, $list-2) {
  $output: ();

  @each $value-of-2 in $list-2 {
    $output: append($output, index($list-1, $value-of-2));
  }

  @return $output;
}

// Nth getter
// -------------------------
// returns list with items from $list by indexes
@function nths($list, $indexes) {
  $output: ();

  @each $index in $indexes {
    @if $index {
      $output: append($output, nth($list, $index));
    }
  }

  @return $output;
}

// Remove item list by value name
// -------------------------
@function remove-value($list, $value:null, $separator:auto)
{
  $output: ();
  @each $val-of-first in $list {
    @if $val-of-first != $value {
      $output: append($output, $val-of-first, $separator);
    }
  }

  @return $output;
}

// Remove item list by index 
// -------------------------
@function remove-nth($list, $index:null, $separator:auto)
{
  $output: ();
  @if $index {
    @each $val-of-first in $list {
      @if $val-of-first != $index {
        $output: append($output, $val-of-first, $separator);
      }
    }

    @return $output;
  }
  @else {
    @return $list;
  }
}

// Appends value to map
// ------------------------
// appends $value by $key to the $map. If $key exists appends to existing
// values, if doesn't return map with new $key and $value.
@function map-append-val($map, $key, $value, $separator:auto) {
  $temp: (
    $key: append(map-get($map, $key), $value, $separator)
  );
  @return map-merge($map, $temp);
}

// Merge map values
// -------------------------
// merge $map2 into $map1. If there are the same keys values from $map2
// appending to existing values of $map1. If aren't new keys created.
@function map-union($map1, $map2) {
  @each $key, $val in $map2 {
    $map1: map-append-val($map1, $key, $val);
  }
  @return $map1;
}


// Functions implementing CSS Unit manipulations
// --------------------------------------------------
// Unit Remover
// -------------------------
@function ununit($value) {
  @if unitless($value)              { @return $value; }
  @else if unit($value) == '%'      { @return $value / 1%; }
  @else if unit($value) == 'px'     { @return $value / 1px; }
  @else if unit($value) == 'pt'     { @return $value / 1pt; }
  @else if unit($value) == 'em'     { @return $value / 1em; }
  @else if unit($value) == 'rem'    { @return $value / 1rem; }
}

// Unit Appender
// -------------------------
@function setunit($value, $unit: integer) {
  @if $unit == integer              { @return ununit($value); }
  @else if $unit == '%'             { @return ununit($value)+0%; }
  @else if $unit == 'px'            { @return ununit($value)+0px; }
  @else if $unit == 'pt'            { @return ununit($value)+0pt; }
  @else if $unit == 'em'            { @return ununit($value)+0em; }
  @else if $unit == 'rem'           { @return ununit($value)+0rem; }
}

// Unit Converter (without rounding)
// -------------------------
// $value numeral - any CSS unit or unitless value: 100px, 1.4rem, 1.6, 7pt etc
// $unit unit - any valid CSS unit: rem, '%', '' (unitless), px, em, auto (auto detection) etc
@function _tounit($value, $unit: null, $pixel-size: 16, $ppi-ratio: 72/96) {
  @if $unit == 'auto' {
    $unit: unit($value)
  }

  @if $unit {
    // px
    @if unit($value) == 'px' {
      @if $unit == 'px'             { @return $value; }
      @else if $unit == '%'         { @return setunit($value * 100 / $pixel-size, '%'); }
      @else if $unit == 'pt'        { @return setunit($value * $ppi-ratio, pt); }
      @else if $unit == 'em'        { @return setunit($value / $pixel-size, em); }
      @else if $unit == 'rem'       { @return setunit($value / $pixel-size, rem); }
      @else if $unit == ''          { @return setunit($value / $pixel-size); }
    }

    // percent
    @else if unit($value) == '%' {
      $value: round($value * $pixel-size/100) / ($pixel-size/100);
      @if $unit == '%'              { @return $value; }
      @else if $unit == 'px'        { @return setunit($value * $pixel-size/100, px); }
      @else if $unit == 'pt'        { @return setunit($value * $pixel-size/100 * $ppi-ratio, pt); }
      @else if $unit == 'em'        { @return setunit($value / 100, em); }
      @else if $unit == 'rem'       { @return setunit($value / 100, rem); }
      @else if $unit == ''          { @return setunit($value / 100); }
    }

    // em, rem, unitless
    @else if unit($value) == 'em' or unit($value) == 'rem' or unitless($value) {
      @if $unit == '%'              { @return setunit(ununit($value) * 100, '%'); }
      @else if $unit == 'px'        { @return setunit($value * $pixel-size, px); } //round?
      @else if $unit == 'pt'        { @return setunit(ununit($value) * $pixel-size * $ppi-ratio, pt); }
      @else if $unit == 'em'        { @return setunit($value, em); }
      @else if $unit == 'rem'       { @return setunit($value, rem); }
      @else if $unit == ''          { @return setunit($value); }
    }

    // pt
    @else if unit($value) == 'pt' {
      @if $unit == '%'              { @return setunit(ununit($value) / $ppi-ratio * 100/ununit($pixel-size), '%'); }
      @else if $unit == 'px'        { @return setunit(round($value / $ppi-ratio), px); }
      @else if $unit == 'pt'        { @return $value; }
      @else if $unit == 'em'        { @return setunit(ununit($value) / $ppi-ratio / $pixel-size, em); }
      @else if $unit == 'rem'       { @return setunit(ununit($value) / $ppi-ratio / $pixel-size, rem); }
      @else if $unit == ''          { @return setunit(ununit($value) / $ppi-ratio / $pixel-size); }
    }

    // if unit is not detected just return
    @else {
      @return $value;
    }
  }
  // if $unit is not defined just return
  @else {
    @return $value;
  }
}

// Unit Converter (with rounding)
// -------------------------
// Converts input $value to given $unit so that returned value
// become integer pixel at the end of browser rendering
@function tounit($value, $unit: auto) {
  @if $unit == 'auto' {
    @return _tounit(round(_tounit($value, px)), unit($value));
  } @else {
    @return _tounit(round(_tounit($value, px)), $unit);
  }
}


// Grid Settings Calculator
// --------------------------------------------------
// $columns - number of grid columns
// $calc-method - method based on what will be made calculation
// $calc-data - input data for calculation according to selected method
// @return list - 1:columns number, 2:column width, 3:gap width
@function calc-grid($columns, $calc-method, $calc-data)
{
  $column: null;
  $gap: null;

  // gaps by padding
  @if $calc-method==column-gap {
    $px-column: nth($calc-data,1);
    $px-gap: nth($calc-data,2);
    $px-row: ($columns * $px-column) + ($px-gap * ($columns - 1));
    $percent-gap: percentage($px-gap/$px-row);

    $column: 100% / $columns;
    $gap: $percent-gap/2;
  }
  @else if $calc-method==gap {
    $gap: $calc-data;

    $column: 100% / $columns;
    $gap: $gap/2;
  }
  @else if $calc-method==column {
    $ratio: $calc-data;

    $column: 100% / $columns;
    $gap: (100% - ($ratio * $columns)) / $columns;
  }

  @return ($columns, $column, $gap);
}


// Media Builder
// --------------------------------------------------
// $media-map map - map where key is name of query, value is the query itself. Example:
//    $media-map: (
//       mobile:   media '(screen and (max-width: 740px )',
//       touch:    '.touch',
//       ^name     ^query
//    );
// $media-name string - key of corresponding key-value pair in $media-map. Example: mobile or touch
// $unit unit - convert numbers are presented in query in accordance with $unit
@mixin media($media-name, $media-map:null, $unit:$_media-unit) {
  // if media map is not null
  @if $media-map {
    // get query with the associated name
    $media-query: map-get($media-map, $media-name);

    // if query is presented in the map
    @if $media-query {
      $query-string: ();
      $query-type: null;

      // fetch query string from key's value
      @for $i from 1 through length($media-query) {
        $value: nth($media-query, $i);
        // if first item of query is 'media' keyword the content must be under @media rule
        // else under simple CSS selector, like .myclass {@content;}
        @if $i == 1 {
          $query-type: if($value==media, media, selector);
        }

        // if one of the query item is number - convert it according to $unit unit
        $value: if(type-of($value)==number, tounit($value, $unit), unquote($value));

        // fetch query string
        $query-string: append($query-string, if($value!=media, $value, null));
      }

      @if $query-type == media {
        @media #{$query-string} {@content;}
      }
      @else if $query-type == selector{
        // selector & {@content} (deprecated?)
        #{$query-string} {@content;}
      }

    // render content with no query
    } @else {
      @content;
    }
  } @else {
      @content;
  }
}


// Underlying function and mixins implementing "Sets"
// --------------------------------------------------
// Render actual CSS of set
// -------------------------
// Analyze set data and renders actual CSS styles.
// $property-shortcut string - class prefix for for given CSS property
// $selector-type:
// '%' = placeholder, generate no content (need only for @extend operator)
// '.' = class, default behaviour generate common selectors
@mixin _generate-set($property-shortcut, $property-name, $selector-type, $set-values, $media-name:null) {
  // Initialize constructor variables
  // ---------------
  // Variables changing during loop:
  $media-prefix: null;
  $media-postfix: null;
  $class-prefix: null;
  $class-postfix: null;
  $selector-before: (null);
  $selector-after: (null);

  $i: 1; // offset/cursor position
  @while $i <= length($set-values) {
    // set cursor of the loop
    $current: nth($set-values, $i);

    // Step 0
    // ---------------
    // Prepend/append/clean media query name.
    @if $current == prefix {
      $media-prefix: __($media-name);
      $media-postfix:null;
      $i: $i + 1;
    }
    @if $current == postfix {
      $media-prefix:null;
      $media-postfix: _($media-name);
      $i: $i + 1;
    }
    @else if $current == unfix {
      $media-prefix:null;
      $media-postfix:null;
      $i: $i + 1;
    }

    // Step 1
    // ---------------
    // Get CSS selectors if presented.
    $current: nth($set-values, $i);
    @if length($current) == 3 {
      $selector-before: nth($current, 1);
      $selector-after: nth($current, 3);
      $i: $i + 1;
    }

    // Step 2
    // ---------------
    // Get class name.
    $current: nth($set-values, $i);
    $i: $i + 1;
    // if pre/postfix class names are presented
    @if length($current) == 2 {
      $class-prefix: #{nth($current, 1)}_;
      $class-postfix: nth($current, 2);
    }
    // if there is only class postfix
    @else {
      $class-prefix: null; // reset prefix
      $class-postfix: $current;
    }

    // Step 3
    // ---------------
    // Get property value.
    $current: nth($set-values, $i);
    $i: $i + 1;
    // append null for correct handling values within the loop
    $property-value: $current, null;

    // Step 4
    // ---------------
    // Construct selector and render.
    // append dash if class-postfix in not null and _
    $class-shortcut: if($class-postfix != null, __($property-shortcut), $property-shortcut);
    // selector types of by default
    $types: '%' '.';
    // get specific type(s) if presented
    @if length($selector-type) > 0 and $selector-type != null{
      $types: $selector-type;
    }

    // go through each selector type
    @each $type in $types {
      // construct
      $selector:
        #{$selector-before}#{$type}#{$media-prefix}#{$class-prefix}#{$class-shortcut}#{$class-postfix}#{$media-postfix}#{$selector-after};
      // [any CSS selector]+[. / %]+[   laptop-   ]+[  myprefix-  ]+[    border-    ]+[  -black-thin ]+[   -laptop    ]+[any CSS selector]
      // notes: constructor use either $media-prefix or $media-postfix, but not both at once

      // render
      #{$selector} {
        // if set has several CSS properties at once specify the same value for all of them
        @each $property in $property-name {
          #{$property}: $property-value;
        }
      }
    }

  }
}

// Retrieve 3 types of data from $data.
// -------------------------
// 1:property name(s), 2:selector type(s), 3:set values
@function _split-set-data($data, $type) {
  // Get Property Name(s)
  // ---------------
  $property-name: nth($data, 1); // comes first
  @if $type == property-name { @return $property-name; }

  // Get Selector Type(s)
  // ---------------
  $selector-type: (); $i: 1;
  $types: nth($data, 2); // comes second (after property name)
  @while ($i <= 2 and $i <= length($types)) and (nth($types, $i) == '%' or nth($types, $i) == '.') {
    $selector-type: append($selector-type, nth($types, $i));
    $i: $i + 1;
  }
  @if $type == selector-type { @return $selector-type; }

  // Get Set Values
  // ---------------
  $set-values: ();
  // if selector type(s) detected
  @if length($selector-type) > 0 {
    $set-values: nth($data, 3); // comes third (after selector type)
  } @else {
    $set-values: nth($data, 2); // comes second (after property name)
  }
  @if $type == set-values { @return $set-values; }

  // Return All Together
  // ---------------
  @if length($type) == 2 { // property name & selector type
    @return ($property-name $selector-type);
  }
  @if length($type) == 3 { // property name & set values & selector type
    // $selector-type comes last because it could be empty
    @return ($property-name $set-values $selector-type);
  }
}

// Return map of sets
// -------------------------
// Retrieve sets from $data and store them into single map and return
@function _get-sets($property-shortcut, $data, $media-map:null) {
  // fetch data
  $data: _split-set-data($data, property-name set-values selector-type);
  $property-name: nth($data, 1);
  $set-values:    nth($data, 2);
  $selector-type: nth($data, 3);
  // temp vars to fetch data
  $temp: ();
  $temp-names: ();
  @if $media-map {
    // get all available media query names
    $media-names: map-keys($media-map);

    @each $key, $val in $set-values {
      // Keyword 'all'
      // -------------
      // under all media queries
      @if $key == all {
        $temp-names: $media-names;
        $set-values: $val;
      }

      // Keyword 'media*'
      // --------------
      // under specified media queries
      @else if str-exists($key, media) {
        // if 'all' - under all media except default, else under list of specified media
        $specified-names: nth($val, 1);
        $temp-names: if($specified-names == all, remove-value($media-names, default), $specified-names);
        $set-values: nth($val, 2);
      }

      // No keywords
      // -------------
      // under one media specified by $key
      @else {
        $temp-names: $key;
        $set-values: $val;
      }

      @each $name in $temp-names {
        $temp: map-append-val($temp, $name, ($property-shortcut $property-name $selector-type $set-values));
      }
    }
  }
  // there is no media just pass
  @else {
    $temp: map-append-val($temp, default, ($property-shortcut $property-name $selector-type $set-values));
  }

  @return $temp;
}

// Basic methods for use "Sets"
// --------------------------------------------------
// Store sets into $storage
// -------------------------
@function store-set($storage, $property-shortcut, $data, $media-map:null) {
  $property-shortcut: if($property-shortcut == none, null, $property-shortcut);

  @if length($data) == 0 or $data == null  {
    @error 'ELEMENT @function store-set(): nothing to store - 3th argument is empty.';
  }
  $temp: _get-sets($property-shortcut, $data, $media-map);
  @return map-union($storage, $temp);
}

// Generates number of sets from $storage
// -------------------------
@mixin sets($storage, $media-map:null, $media-unit:$_media-unit) {
  @if length($storage) == 0 or $storage == null {
    @error 'ELEMENT @mixin sets(): nothing to render - 1st argument is empty.';
  }
  @each $media-name, $sets in $storage {
    @include media($media-name, $media-map, $media-unit) {
      @each $set in $sets {@each $s in $set { // get rid of empty elements
        @if $s {
          @include _generate-set(nth($s, 1), nth($s, 2), nth($s, 3), nth($s, 4), $media-name);
        }
      }}
    }
  }
}

// Generates only one set
// -------------------------
@mixin set($property-shortcut, $data, $media-map:null, $media-unit:$_media-unit) {
  $storage: store-set((), $property-shortcut, $data, $media-map);
  @include sets($storage, $media-map, $media-unit);
}
