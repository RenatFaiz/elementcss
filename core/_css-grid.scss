// _g
// generates CSS styles of different grid element types.
// $params contains 3 grid parameters: 1:columns number, 2:column width, 3:gap width.
// $params should be generated by _calc() function. $element is a name of grid element
// type whose styles represent its behaviour. Type names start with _ initialize base
// styles and should be used only once. Other types can be used many times under @media rule.
@mixin _g($type, $element, $params:null, $i:1) {
  $column-width: null;
  $gap-width: null;
  // if params are presented
  @if length($params) == 3 {
    $column-width:  nth($params, 2);
    $gap-width:     nth($params, 3);
  }

  // Row Types
  // --------------------
  @if $element==_row {
    @if index($type, flexbox) {
      display: flex;
      padding: 0;
      box-sizing: border-box;
      flex-wrap: if($_left == left, wrap, wrap-reverse);
    } @else if index($type, float) {
      display: block;
      padding: 0;
      box-sizing: border-box;
      @include clearfix();
    }
  }
  @else if $element==row-gutter {
    margin-#{$_left}: -$gap-width * 2;
  }

  // Column Types
  // --------------------
  @else if $element==_column {
    @if index($type, flexbox) {
      display: flex;
      box-sizing: border-box;
      flex-direction: column; // full width of elements inside
      flex:0 1 auto; // no folding on empty column
      min-height:1px; // no folding on empty column
    } @else if index($type, float) {
      float: $_left;
      display: block;
      box-sizing: border-box;
      min-height:1px; // no folding on empty column
    }
  }
  @else if $element==column-width {
    @if index($type, flexbox) {
      flex-basis: if($i==0, auto, $column-width * $i);
      max-width: if($i==0, none, $column-width * $i);
    } @else if index($type, float) {
      width: if($i==0, auto, $column-width * $i);
    }
  }
  @else if $element==column-gutter {
    padding-#{$_left}: $gap-width * 2;
  }

  // Column Manipulators
  // ---------------------
  @else if $element==column-offset {
    margin-#{$_left}: $column-width * $i;
  }
  @else if $element==column-unoffset {
    margin-#{$_left}: 0;
    margin-#{$_right}: 0;
  }
  @else if $element==column-push {
    #{$_left}: $column-width * $i;
    #{$_right}: auto;
  }
  @else if $element==column-pull {
    #{$_right}: $column-width * $i;
    #{$_left}: auto;
  }
  @else if $element==column-unpush or $element==column-unpull {
    left:auto;
    right:auto;
  }
  @else if $element==column-centred-x {
    margin-#{$_left}: auto;
    margin-#{$_right}: auto;
    @if index($type, float) {
      float: none;
    }
  }
  @else if $element==column-uncentred-x {
    margin-#{$_left}: 0;
    margin-#{$_right}: 0;
    @if index($type, float) {
      float: $_left;
    }
  }
  @else if $element==column-centred-y {
    @if index($type, flexbox) {
      align-self: center;
    }
  }
  @else if $element==column-uncentred-y {
    @if index($type, flexbox) {
      align-self: auto;
    }
  }
}

// grid
// generates classes that provide convenient and flexible way to create
// responsive page layout.
// (!) float grid type may deprecated and deleted in the future
// flexbox, float
@mixin grid($type, $data, $query-map:null, $rows: gutter columned) {
  // columned row - automatically set column width on child elements
  // gutter row - automatically set gutters between columns
  $rows: gutter, columned; // gutter, columned

  // grid calculation parameters and composition
  $params: null; // default params
  $set: column; // default set
  $map: (default: $set); // default map

  // retrieve/rewrite defaults from $data
  // 1 $data: (params)
  // 2 $data: (params) (set)
  // 3 $data: (params) (key: set|params, ..)
  // 4 $data: (params) (set) (key: set|params, ..)
  // 5 $data: (key: set|params, ..)
  @if length($data) >= 3 and type-of(nth($data, 1)) == number { // 1
    $params: calc-grid(all, $data);
  } @else if length($data) >= 2 {
    @if length(nth($data, 1)) >= 3 {
      $params: calc-grid(all, nth($data, 1));
      @if type-of(nth($data, 2)) != map { // 2
        $set: nth($data, 2);
        $map: if($set == null, null, (default: $set));
      } @else if type-of(nth($data, 2)) == map { // 3
        $map: map-merge($map, nth($data, 2));
      }
      @if length($data) == 3 and type-of(nth($data, 3)) == map { // 4
        $set: nth($data, 2);
        $map: if($set == null, nth($data, 3), map-merge($map, nth($data, 3)));
      }
    }
  } @else if type-of($data) == map { // 5
    $map: $data;
  } @else {
    @error "@mixin grid(): wrong syntax of 2nd argument. Please, check the syntax."
  }
  //@debug $params, $set, $map;

  // Query classes
  // -------------------------
  $iscolumn: false; // check if any of query has column set
  @each $name, $val in $map {
    $prefix: __($name, '_', true);
    $s: $set;
    $p: $params;

    // retrieve/rewrite defaults if query has its own params or/and set
    // 1 key: (params),
    // 2 key: (params) (set),
    // 3 key: (set),
    @if length($data) >= 3 and type-of(nth($data, 1)) == number { // 1
      $p: calc-grid(all, nth($val, 1));
    } @else if length(nth($val, 1)) >= 3 and type-of(nth(nth($val, 1),1)) == number { // 2
      $p: calc-grid(all, nth($val, 1));
      $_: slice($val, 2);
      $s: if(nth($_, 1) == add, merge($s, slice($_, 2)), $_);
    } @else { // 3
      $s: if(nth($val, 1) == add, merge($s, slice($val, 2)), $val);
    }
  @debug $p;
    @include media($name, $query-map) {
      // Column width
      // --------------------
      @if index($s, column) {
        $iscolumn: true;
        // gutter mode
        @if index($rows, gutter) {
          // row
          ._gutter { @include _g($type, row-gutter, $p); }
          // column
          $_column-gutter: unquote('._gutter [class*="_col-"]');
          // columned mode
          @if index($rows, columned) {
            $_column-gutter: append($_column-gutter, unquote('._gutter[class*="_cols-"] > *'), comma);
          }
          // render
          #{$_column-gutter} { @include _g($type, column-gutter, $p); }
        }

        // generate column width
        @for $i from 0 through nth($p, 1) {
          // 0 index have auto width
          $idx: if($i == 0, 'auto', $i);
          // column
          $_column-width: unquote('.#{$prefix}col-#{$idx}');
          // columned mode
          @if index($rows, columned) {
            $_column-width: append($_column-width, unquote('.#{$prefix}cols-#{$idx} > *'), comma);
          }
          // render
          #{$_column-width} { @include _g($type, column-width, $p, $i); }
        }

        // centering
        .#{$prefix}center-x { @include _g($type, column-centred-x); }
        .#{$prefix}center-y { @include _g($type, column-centred-y); }

        // uncentering
        .#{$prefix}uncenter-x { @include _g($type, column-uncentred-x); }
        .#{$prefix}uncenter-y { @include _g($type, column-uncentred-y); }
      }

      // Offset
      // --------------------
      @if index($s, offset) {
        @for $i from 1 through nth($p, 1) {
          .#{$prefix}offs-#{$i} { @include _g($type, column-offset, $p, $i); }
        }
        .#{$prefix}unoffs { @include _g($type, column-unoffset); }
      }

      // Push
      // --------------------
      @if index($s, push) {
        [class*="_push-"] { position: relative; }
        @for $i from 1 through nth($p, 1) {
          .#{$prefix}push-#{$i} { @include _g($type, column-push, $p, $i); }
        }
        .#{$prefix}unpush { @include _g($type, column-unpush); }
      }

      // Pull
      // --------------------
      @if index($s, pull) {
        [class*="_pull-"] { position: relative; }
        @for $i from 1 through nth($p, 1) {
          .#{$prefix}pull-#{$i} { @include _g($type, column-pull, $p, $i); }
        }
        .#{$prefix}unpull { @include _g($type, column-unpull); }
      }
    }
  }

  // Base classes
  // -------------------------
  @if $iscolumn {
    // row
    ._row { @include _g($type, _row); }
    // gutter row mode
    @if index($rows, gutter) {
      ._gutter { position: relative; }
    }
    // float based row modes
    @if index($type, float) {
      ._row._reverse [class*="_col-"] { float: right; }
      ._row._column [class*="_col-"]  { clear: both; }
    }

    // column
    // $_* vars aggregates selectors to avoid duplicate styles (DRYCSS)
    $_column: unquote('[class*="_col-"]');
    // columned row mode
    @if index($rows, columned) {
      $_column: append($_column, unquote('[class*="_cols-"] > *'), comma);
      [class*="_cols-"] { list-style:none; }
    }
    // render
    #{$_column} { @include _g($type, _column); }
  }
}
