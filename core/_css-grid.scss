// _css-grid.scss provides grid() mixin to generate flexible grid systems under
// unlimited @media rules.

// _g
// generates CSS styles of different grid element types.
// $params contains 3 grid parameters: 1:columns number, 2:column width, 3:gap width.
// $params should be generated by _calc() function. $element is a name of grid element
// type whose styles represent its behaviour. Type names start with _ initialize base
// styles and should be used only once. Other types can be used many times under @media rule.
@mixin _g($type, $dir, $element, $params:null, $i:1, $dir:ltr) {
  // defaults
  $left: if($dir == ltr, left, right);
  $right: if($dir == ltr, right, left);
  $column-width: null;
  $gap-width: null;
  // if params are presented
  @if length($params) == 3 {
    $column-width:  nth($params, 2);
    $gap-width:     nth($params, 3);
  }

  // Row Types
  // --------------------
  @if $element==_row {
    @if index($type, flexbox) {
      display: flex;
      padding: 0;
      box-sizing: border-box;
      flex-wrap: if($left == left, wrap, wrap-reverse);
    } @else if index($type, float) {
      display: block;
      padding: 0;
      box-sizing: border-box;
      @include clearfix();
    }
  }
  @else if $element==row-gutter {
    margin-#{$left}: -$gap-width;
  }

  // Column Types
  // --------------------
  @else if $element==_column {
    @if index($type, flexbox) {
      display: flex;
      box-sizing: border-box;
      flex-direction: column; // full width of elements inside
      flex:0 1 auto; // no folding on empty column
      min-height:1px; // no folding on empty column
    } @else if index($type, float) {
      float: $left;
      display: block;
      box-sizing: border-box;
      min-height:1px; // no folding on empty column
    }
  }
  @else if $element==column-width {
    @if index($type, flexbox) {
      flex-basis: if($i==0, auto, $column-width * $i);
      max-width: if($i==0, none, $column-width * $i);
    } @else if index($type, float) {
      width: if($i==0, auto, $column-width * $i);
    }
  }
  @else if $element==column-gutter {
    padding-#{$left}: $gap-width;
  }

  // Column Manipulators
  // ---------------------
  @else if $element==column-offset {
    margin-#{$left}: $column-width * $i;
  }
  @else if $element==column-unoffset {
    margin-#{$left}: 0;
    margin-#{$right}: 0;
  }
  @else if $element==column-push {
    #{$left}: $column-width * $i;
    #{$right}: auto;
  }
  @else if $element==column-pull {
    #{$right}: $column-width * $i;
    #{$left}: auto;
  }
  @else if $element==column-unpush or $element==column-unpull {
    left:auto;
    right:auto;
  }
  @else if $element==column-centred-x {
    margin-#{$left}: auto;
    margin-#{$right}: auto;
    @if index($type, float) {
      float: none;
    }
  }
  @else if $element==column-uncentred-x {
    margin-#{$left}: 0;
    margin-#{$right}: 0;
    @if index($type, float) {
      float: $left;
    }
  }
  @else if $element==column-centred-y {
    @if index($type, flexbox) {
      align-self: center;
    }
  }
  @else if $element==column-uncentred-y {
    @if index($type, flexbox) {
      align-self: auto;
    }
  }
}

// _get-params
// returns calculated grid parameters and grid set in unified form. Format:
//    @return grid-params, grid-set
//            (12 8.333% 3%), (column push pull)
@function _get-params($d) {
  // 1. $d:(params)
  // 2. $d:(params) (set)
  // 3. $d:(set)
  // 4. $d:?
  @if length($d) >= 3 and type-of(nth($d, 1)) == number { //1
    @return (p:calc-grid(all, $d));
  }
  @if length($d) >= 2 and length(nth($d, 1)) >= 3 { //2
    @return (p:calc-grid(all, nth($d, 1)), s:slice($d, 2));
  }
  @if $d {
    @return (s:$d); //3
  }
  @return (p:null,s:null); //4
}

// grid
// generatesa grid system classes. $type can be flexbox or float. 1st uses new
// CSS4 flexbox properties; 2nd is "classic" layout using block and floats.
// $data is notation to define what grid modules and @media rules should be
// generated. $rows define additional row modes. grid() mixin can be complex at first
// glance, but its output is minimal and exactly what you want. Just play with
// examples and see what you.
//
// columned row - automatically set column width on child elements
// gutter row - automatically set gutters between columns
// $data consist from 2 parts: grid params and grid set. Params syntax is:
// number-of-colums calc-type calc-basis, examples:
//    12 gap 3%
//    8 column 7%
//    10 column-gap 20px 80px
// grid-set can be column, offset, push, pull
@mixin grid($type, $data, $query-map:null, $rows:gutter columned, $dir:ltr) {
  // prepare query map and query name list
  $q-map: if(length($query-map) == 2 and type-of(nth($query-map, 2)) == map,
  nth($query-map, 2), $query-map);
  $q-names: if($q-map, map-keys($q-map), ());

  // prepare grid database
  $db:();
  @if type-of($data) == map {
    $all: null;
    @each $key, $params in $data {
      //@debug K $key V $params DB $db;
      // all:
      @if $key == all {
        $all: _get-params($params); // global params
        // go through all available queries and add root if isn't specified
        @each $q in union($q-names, root, pre) {
          $db: map-merge($db, ($q:$all));
        }
      }
      // query*:
      @else if has-prefix($key, 'query') {
        $subq: nth($params, 1); // names after (query: (names) (...))
        $params: unwrap(slice($params, 2));
        // all queries, except root
        @if $subq == all {
          @each $q in remove($q-names, root) {
            @if map-get($q-map, $q) { $db: map-merge($db, ($q:$params)); }
          }
        }
        // explicitly specified
        @else {
          @each $q in $subq {
            @if map-get($q-map, $q) { $db: map-merge($db, ($q:$params)); }
          }
        }
      }
      // root/others:
      @else {
        $cur: _get-params($params);
        $tmp: if(map-empty($all), $cur, map-merge($all,$cur));
        $db: map-merge($db, ($key:$tmp));
      }
    }
  }
  // $data is root parameter then
  @else {
    $db: (root: _get-params($data));
  }

  //@debug FINAL DB $db;

  // Base classes
  // -------------------------
  // TODO
  // @each $k, $v in $db {
  //   @if index($v, column) {
  //   }
  // }
  // row
  ._row { @include _g($type, $dir, _row); }
  // gutter row mode
  @if index($rows, gutter) {
    ._gutter { position: relative; }
  }
  // float based row modes
  @if index($type, float) {
    ._row._reverse [class*="_col-"] { float: right; }
    ._row._column [class*="_col-"]  { clear: both; }
  }

  // column
  // $_* vars aggregates selectors to avoid duplicate styles (DRYCSS)
  $_column: unquote('[class*="_col-"]');
  // columned row mode
  @if index($rows, columned) {
    $_column: append($_column, unquote('[class*="_cols-"] > *'), comma);
    [class*="_cols-"] { list-style:none; }
  }
  // render
  #{$_column} { @include _g($type, $dir, _column); }
  //}

  // Query classes
  // -------------------------
  @each $q-name, $g-params in $db {
    $s: map-get($g-params,s);
    $p: map-get($g-params,p);

    @include media($q-name, $query-map) {
      $prefix: postfix($q-name, '_', true);
      // Column width
      // --------------------
      @if index($s, column) {
        // gutter mode
        @if index($rows, gutter) {
          // row
          ._gutter { @include _g($type, $dir, row-gutter, $p); }
          // column
          $_column-gutter: unquote('._gutter [class*="_col-"]');
          // columned mode
          @if index($rows, columned) {
            $_column-gutter: append($_column-gutter, unquote('._gutter[class*="_cols-"] > *'), comma);
          }
          // render
          #{$_column-gutter} { @include _g($type, $dir, column-gutter, $p); }
        }

        // generate column width
        @for $i from 0 through nth($p, 1) {
          // 0 index have auto width
          $idx: if($i == 0, 'auto', $i);
          // column
          $_column-width: unquote('.#{$prefix}col-#{$idx}');
          // columned mode
          @if index($rows, columned) {
            $_column-width: append($_column-width, unquote('.#{$prefix}cols-#{$idx} > *'), comma);
          }
          // render
          #{$_column-width} { @include _g($type, $dir, column-width, $p, $i); }
        }

        // centering
        .#{$prefix}center-x { @include _g($type, $dir, column-centred-x); }
        .#{$prefix}center-y { @include _g($type, $dir, column-centred-y); }

        // uncentering
        .#{$prefix}uncenter-x { @include _g($type, $dir, column-uncentred-x); }
        .#{$prefix}uncenter-y { @include _g($type, $dir, column-uncentred-y); }
      }

      // Offset
      // --------------------
      @if index($s, offset) {
        @for $i from 1 through nth($p, 1) {
          .#{$prefix}offs-#{$i} { @include _g($type, $dir, column-offset, $p, $i); }
        }
        .#{$prefix}unoffs { @include _g($type, $dir, column-unoffset); }
      }

      // Push
      // --------------------
      @if index($s, push) {
        [class*="_push-"] { position: relative; }
        @for $i from 1 through nth($p, 1) {
          .#{$prefix}push-#{$i} { @include _g($type, $dir, column-push, $p, $i); }
        }
        .#{$prefix}unpush { @include _g($type, $dir, column-unpush); }
      }

      // Pull
      // --------------------
      @if index($s, pull) {
        [class*="_pull-"] { position: relative; }
        @for $i from 1 through nth($p, 1) {
          .#{$prefix}pull-#{$i} { @include _g($type, $dir, column-pull, $p, $i); }
        }
        .#{$prefix}unpull { @include _g($type, $dir, column-unpull); }
      }
    }
  }
}
