// _css-set.scss provides functions and mixins implementing Set feature. Underlying
// functions and mixins start with _ (underscore) and should not be used. There are
// only 2 function & 2 mixin are intended for use (go at the end of file).

// _generate-set
// analyze set data and renders actual CSS styles.
// $property-shortcut string - class prefix for for given CSS property.
// $selector-type:
// '%' = placeholder, generate no content (need only for sass @extend operator)
// '.' = class, default behaviour (generate common selectors)
//    _generate-set(bg, background, '.', (green, #84ed28))
//      -> .bg-green {background: #84ed28;}
//    _generate-set(c, color, '.', (red, red), desktop)
//      -> .c-red {color: red;}
//    _generate-set(c, color, '%', (red, red), desktop)
//    .extend {@extend %c-red;}
//      -> .extend {color: red;}
@mixin _generate-set($property-shortcut, $property-name, $selector-type, $set-values, $query-name:null) {
  // Initialize constructor variables
  // ---------------
  // Variables changing during loop:
  $query-prefix: null;
  $query-postfix: null;
  $class-prefix: null;
  $class-postfix: null;
  $selector-before: (null);
  $selector-after: (null);

  $i: 1; // offset/cursor position
  @while $i <= length($set-values) {
    // update cursor on each iteration
    $current: nth($set-values, $i);

    // Step 0
    // ---------------
    // Prepend/append/clean media query name.
    @if $current == prefix {
      $query-prefix: __($query-name);
      $query-postfix:null;
      $i: $i + 1;
    }
    @if $current == postfix {
      $query-prefix:null;
      $query-postfix: _($query-name);
      $i: $i + 1;
    }
    @else if $current == unfix {
      $query-prefix:null;
      $query-postfix:null;
      $i: $i + 1;
    }

    // Step 1
    // ---------------
    // Get CSS selectors if presented.
    $current: nth($set-values, $i);
    @if length($current) == 3 {
      $selector-before: nth($current, 1);
      $selector-after: nth($current, 3);
      $i: $i + 1;
    }

    // Step 2
    // ---------------
    // Get class name.
    $current: nth($set-values, $i);
    $i: $i + 1;
    // if pre/postfix class names are presented
    @if length($current) == 2 {
      $class-prefix: nth($current, 1); // or #{nth($current, 1)}_
      $class-postfix: nth($current, 2);
    }
    // if there is only class postfix
    @else {
      $class-prefix: null; // reset prefix
      $class-postfix: $current;
    }

    // Step 3
    // ---------------
    // Get property value.
    $current: nth($set-values, $i);
    $i: $i + 1;
    $property-value: null;
    @if length($current) >= 3 and nth($current, 2) == _ {
      $property-value: $current;
    } @else {
      // append null for correct handling values within the loop
      $property-value: $current, null;
    }

    // Step 4
    // ---------------
    // Get property shortcut
    // append dash if class-postfix isn't null and do not start with _
    $class-shortcut: if($class-postfix != null
      // [feature: _-_name -> __name]
      and str-slice(#{$class-postfix}, 1, 1) != '_',
      __($property-shortcut), $property-shortcut);

    // Step 5
    // ---------------
    // Get selector type
    // selector types of by default
    $types: '%' '.';
    // get specific type(s) if presented
    @if length($selector-type) > 0 and $selector-type != null{
      $types: $selector-type;
    }

    // Step 6
    // ---------------
    // Construct selector and render going through each selector type
    @each $type in $types {
      // construct
      $selector:
        #{$selector-before}#{$type}#{$query-prefix}#{$class-prefix}#{$class-shortcut}#{$class-postfix}#{$query-postfix}#{$selector-after};
      // [any CSS selector]+[. / %]+[   laptop-   ]+[  myprefix   ]+[      bg-      ]+[     black    ]+[   -laptop    ]+[any CSS selector]
      // notes: constructor use either $query-prefix or $query-postfix, but not both at once

      // render
      #{$selector} {
        // if set has several CSS properties at once, here two scenarios:
        //  1 - specify the same value for all properties if there is only one CSS value
        //  2 - specify different values for each property comes subsequently, using the
        //     the following syntax: prefix, (1st property value) _ (2st property value),
        $n: 1;
        @for $i from 1 through length($property-name) {
          // scenario 2
          @if nth($property-value, 2) == _ {
            @if $n <= length($property-value) {
              #{nth($property-name, $i)}: nth($property-value, $n);
              $n: $n + 2;
            } @else {
              #{nth($property-name, $i)}: nth($property-value, $n - 2);
            }
          // scenario 1
          } @else {
            #{nth($property-name, $i)}: nth($property-value, 1);
          }
        }
      }
    }
  }
}

// _split-set-data
// retrieves 3 types of data from $data. 1 = property-name, 2 = selector-type,
// 3 = set-values
@function _split-set-data($data, $type) {
  // Get Property Name(s)
  // ---------------
  $property-name: nth($data, 1); // comes first
  @if $type == property-name { @return $property-name; }

  // Get Selector Type(s)
  // ---------------
  $selector-type: ();
  $types: nth($data, 2); // comes second (after property name)
  $i: 1; // cursor
  @if length($types) <= 2 {
    @while ($i <= 2 and $i <= length($types)) {
      $t: nth($types, $i);
      //or $t == ":" or $t == "::"
      @if type-of($t) == string and ($t == "." or $t == "%" or $t == "#" or $t == "") {
        $selector-type: append($selector-type, nth($types, $i));
      }
      $i: $i + 1;
    }
  }
  @if $type == selector-type { @return $selector-type; }

  // Get Set Values
  // ---------------
  $set-values: ();
  // if selector type(s) detected
  @if length($selector-type) > 0 {
    $set-values: nth($data, 3); // comes third (after selector type)
  } @else {
    $set-values: nth($data, 2); // comes second (after property name)
  }
  @if $type == set-values { @return $set-values; }

  // Return All Together
  // ---------------
  @if length($type) == 2 { // property name & selector type
    @return ($property-name $selector-type);
  }
  @if length($type) == 3 { // property name & set values & selector type
    // $selector-type comes last because it could be empty
    @return ($property-name $set-values $selector-type);
  }
}

// _get-set-map
// returns map of set's data. Retrieve sets from $data, store into single map and return.
//    _get-sets(bg, background (green, #84ed28))
//      -> (default: (bg background () (green, #84ed28)))
//    _get-sets(pdd, padding (def, 20px), null)
//      -> (default: (pdd padding () (def, 20px)))
@function _get-set-map($property-shortcut, $data, $query-map:null) {
  // fetch data
  $data: _split-set-data($data, property-name set-values selector-type);
  $property-name: nth($data, 1);
  $set-values:    nth($data, 2);
  $selector-type: nth($data, 3);

  $result-map: (); // resulting map
  @if type-of($set-values) == map {
    $result-names: (); // result media names
    @each $key, $val in $set-values {
      @if $key == all or has-prefix($key, query) {
        @if $query-map == null {
          @error '@function add()/@mixin set(): provide query map for `#{$property-name}` set - 4th/3nd argument is empty.';
        }
        @if length($query-map) == 2 and type-of(nth($query-map, 2)) == map {
          $query-map: nth($query-map, 2);
        }
        $query-names: map-keys($query-map);

        // Keyword 'all'
        // -------------
        // under all queries
        @if $key == all {
          $result-names: join(default, $query-names);
          $set-values: $val;
        }

        // Keyword 'query*'
        // --------------
        // under specified queries
        @else if has-prefix($key, query) {
          $specified-names: nth($val, 1);
          // if 1st item == 'all' generate under all queries except default,
          // else under list of specified queries
          $result-names: if($specified-names == all, value-remove($query-names, default), $specified-names);
          $set-values: nth($val, 2);
        }
      }

      // No keywords
      // -------------
      // under one media specified by $key
      @else {
        $result-names: $key;
        $set-values: $val;
      }

      @each $name in $result-names {
        $result-map: map-append-val($result-map, $name, $property-shortcut $property-name $selector-type $set-values);
      }
    }
  }
  // there is no media just pass
  @else {
    $result-map: map-append-val($result-map, default, $property-shortcut $property-name $selector-type $set-values);
  }

  @return $result-map;
}

// add
// store sets into a given $storage variable.
//    $s: ();
//    $s: add($s, pdd, padding (def, 20px));
//    $s: add($s, mrg, margin (def, 20px));
//      -> (default: (pdd padding () (def, 20px)) (mrg margin () (def, 20px)))
@function add($storage, $property-shortcut, $data, $query-map:null) {
  @if length($data) == 0 or $data == null  {
    @error '@function add()/@mixin set(): nothing to store of `#{$property-shortcut}` set - 3th/2nd argument is empty.';
  }

  // !default variables can't be null, instead we use none
  $property-shortcut: if($property-shortcut == none, null, $property-shortcut);
  @return map-union($storage, _get-set-map($property-shortcut, $data, $query-map));
}

// pass-add
// pass input values and return untouched $storage.
// Useful if you want to stash a given set for a while.
//    add($store, pdd, padding (lg, 100px)); -> [add new set to $store]
//      ok, but what if I want to stash my previous set for while?
//      If so let's rename add() into pass-add()
//    pass-add($store, pdd, padding (lg, 100px)); -> [now $store remains untouched]
@function pass-add($storage, $property-shortcut, $data, $query-map:null) {
  @return $storage;
}

// sets
// generates sets from $storage.
//    @include sets($s) -> .pdd-def {padding: 20px;}
@mixin sets($storage, $query-map:null) {
  @if length($storage) == 0 or $storage == null {
    @error '@mixin sets(): nothing to render - 1st argument is empty.';
  }
  @if length($storage) > 1 and $query-map == null {
    @error '@function add()/@mixin set(): provide query map for your set - 4th/3nd argument is empty.';
  }
  @each $query-name, $sets in $storage {
    @include media($query-name, $query-map) {
      @each $s in $sets {
        //$s: nth($s, 1); extract list: ((a b c d)) -> a b c d
        @if $s {
          @include _generate-set(nth($s, 1), nth($s, 2), nth($s, 3), nth($s, 4), $query-name);
        }
      }
    }
  }
}

// set
// generates the only one given set.
//    @include set(bg, background (red, #ff1b2e))
//      -> .bg-red {background: #ff1b2e;}
//    @include set(indent, (margin padding) (sm, 20px));
//      -> .indent-sm {margin: 20px; padding: 20px;}
@mixin set($property-shortcut, $data, $query-map:null) {
  $storage: add((), $property-shortcut, $data, $query-map);
  @include sets($storage, $query-map);
}

// pass-set
// passes a given set and output nothing.
// Useful if you want to stash a given set for a while.
@mixin pass-set($property-shortcut, $data, $query-map:null) {}
